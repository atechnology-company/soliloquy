# v_rules.gni - GN rules for V language integration and c2v translation

# v_object builds a V source file or translates C to V and produces object files
#
# Parameters:
#   sources: List of V or C source files
#   deps: List of dependencies
#   translate_from_c: If true, use c2v to translate C sources to V first
#   v_flags: Additional flags to pass to the V compiler
#   output_name: Base name for output files (defaults to target name)
#
# Example:
#   v_object("my_module") {
#     sources = [ "src/module.v" ]
#     deps = [ ":other_module" ]
#   }
#
#   v_object("translated_libc") {
#     sources = [ "kernel/lib/libc/string.c" ]
#     translate_from_c = true
#   }
template("v_object") {
  forward_variables_from(invoker, [ "testonly" ])
  
  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "visibility",
                             "sources",
                             "data_deps",
                           ])
    
    _output_name = target_name
    if (defined(invoker.output_name)) {
      _output_name = invoker.output_name
    }
    
    _translate_from_c = false
    if (defined(invoker.translate_from_c)) {
      _translate_from_c = invoker.translate_from_c
    }
    
    _v_flags = []
    if (defined(invoker.v_flags)) {
      _v_flags = invoker.v_flags
    }
    
    # Determine V_HOME from environment or default location
    _v_home = getenv("V_HOME")
    if (_v_home == "") {
      _v_home = rebase_path("${root_build_dir}/../.build-tools/v")
    }
    
    script = "//build/v_compile.py"
    
    outputs = [ "${target_gen_dir}/${_output_name}.o" ]
    
    if (_translate_from_c) {
      # For c2v translation, first translate then compile
      outputs += [ "${target_gen_dir}/${_output_name}.v" ]
    }
    
    args = [
      "--v-home",
      _v_home,
      "--output",
      rebase_path(outputs[0], root_build_dir),
      "--target-name",
      _output_name,
    ]
    
    if (_translate_from_c) {
      args += [ "--translate-c" ]
    }
    
    foreach(flag, _v_flags) {
      args += [
        "--v-flag",
        flag,
      ]
    }
    
    foreach(source, sources) {
      args += [
        "--source",
        rebase_path(source, root_build_dir),
      ]
    }
  }
}

# v_library builds a V library
#
# Parameters:
#   sources: List of V source files
#   deps: List of dependencies
#   output_name: Name for the library (defaults to target name)
template("v_library") {
  v_object(target_name) {
    forward_variables_from(invoker, "*")
  }
}

# c2v_translate translates C sources to V without compiling
#
# Parameters:
#   sources: List of C source files
#   output_dir: Directory for translated V files (defaults to target_gen_dir)
#   deps: List of dependencies
template("c2v_translate") {
  forward_variables_from(invoker, [ "testonly" ])
  
  action(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "visibility",
                             "sources",
                             "data_deps",
                           ])
    
    _output_dir = target_gen_dir
    if (defined(invoker.output_dir)) {
      _output_dir = invoker.output_dir
    }
    
    _v_home = getenv("V_HOME")
    if (_v_home == "") {
      _v_home = rebase_path("${root_build_dir}/../.build-tools/v")
    }
    
    script = "//build/v_translate.py"
    
    outputs = []
    foreach(source, sources) {
      _source_name = get_path_info(source, "name")
      outputs += [ "${_output_dir}/${_source_name}.v" ]
    }
    
    args = [
      "--v-home",
      _v_home,
      "--output-dir",
      rebase_path(_output_dir, root_build_dir),
    ]
    
    foreach(source, sources) {
      args += [
        "--source",
        rebase_path(source, root_build_dir),
      ]
    }
  }
}
